{"/home/travis/build/npmtest/node-npmtest-cordova-sqlite-storage/test.js":"/* istanbul instrument in package npmtest_cordova_sqlite_storage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-sqlite-storage/lib.npmtest_cordova_sqlite_storage.js":"/* istanbul instrument in package npmtest_cordova_sqlite_storage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cordova_sqlite_storage = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cordova_sqlite_storage = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-sqlite-storage/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cordova-sqlite-storage && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cordova_sqlite_storage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cordova_sqlite_storage\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cordova_sqlite_storage.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cordova_sqlite_storage.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cordova_sqlite_storage.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cordova_sqlite_storage.__dirname + '/lib.npmtest_cordova_sqlite_storage.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-sqlite-storage/node_modules/cordova-sqlite-storage/scripts/beforePluginInstall.js":"#!/usr/bin/env node\n\n// Adapted from:\n// https://github.com/AllJoyn-Cordova/cordova-plugin-alljoyn/blob/master/scripts/beforePluginInstall.js\n\nvar path = require('path');\nvar exec = require('child_process').exec;\n\n// XXX FUTURE TBD auto-detect:\nvar package_name = 'cordova-sqlite-storage';\n\nmodule.exports = function (context) {\n    var Q = context.requireCordovaModule('q');\n    var deferral = new Q.defer();\n\n    console.log('installing external dependencies via npm');\n\n    exec(   'npm install', {cwd: path.join('plugins', package_name)},\n            function (error, stdout, stderr) {\n                if (error !== null) {\n                    // XXX TODO SIGNAL FAILURE HERE.\n                    console.log('npm install of external dependencies failed: ' + error);\n                    deferral.resolve();\n                } else {\n                    console.log('npm install of external dependencies ok');\n                    deferral.resolve();\n                }\n            }\n    );\n\n    return deferral.promise;\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-sqlite-storage/node_modules/cordova-sqlite-storage/scripts/prepareSpec.js":"require('shelljs/global');\n\nrm('-rf', 'spec/myplugin');\nrm('-rf', 'spec/plugins');\nrm('-rf', 'spec/platforms');\nmkdir('spec/myplugin')\ncp('-R', 'package.json', 'plugin.xml', 'scripts', 'src', 'www', 'spec/myplugin');\n\ncd('spec');\n\nexec('cordova plugin add myplugin');\n","/home/travis/build/npmtest/node-npmtest-cordova-sqlite-storage/node_modules/cordova-sqlite-storage/www/SQLitePlugin.js":"(function() {\n  var DB_STATE_INIT, DB_STATE_OPEN, READ_ONLY_REGEX, SQLiteFactory, SQLitePlugin, SQLitePluginTransaction, SelfTest, argsArray, dblocations, iosLocationMap, newSQLError, nextTick, root, txLocks;\n\n  root = this;\n\n  READ_ONLY_REGEX = /^(\\s|;)*(?:alter|create|delete|drop|insert|reindex|replace|update)/i;\n\n  DB_STATE_INIT = \"INIT\";\n\n  DB_STATE_OPEN = \"OPEN\";\n\n  txLocks = {};\n\n  newSQLError = function(error, code) {\n    var sqlError;\n    sqlError = error;\n    if (!code) {\n      code = 0;\n    }\n    if (!sqlError) {\n      sqlError = new Error(\"a plugin had an error but provided no response\");\n      sqlError.code = code;\n    }\n    if (typeof sqlError === \"string\") {\n      sqlError = new Error(error);\n      sqlError.code = code;\n    }\n    if (!sqlError.code && sqlError.message) {\n      sqlError.code = code;\n    }\n    if (!sqlError.code && !sqlError.message) {\n      sqlError = new Error(\"an unknown error was returned: \" + JSON.stringify(sqlError));\n      sqlError.code = code;\n    }\n    return sqlError;\n  };\n\n  nextTick = window.setImmediate || function(fun) {\n    window.setTimeout(fun, 0);\n  };\n\n\n  /*\n    Utility that avoids leaking the arguments object. See\n    https://www.npmjs.org/package/argsarray\n   */\n\n  argsArray = function(fun) {\n    return function() {\n      var args, i, len;\n      len = arguments.length;\n      if (len) {\n        args = [];\n        i = -1;\n        while (++i < len) {\n          args[i] = arguments[i];\n        }\n        return fun.call(this, args);\n      } else {\n        return fun.call(this, []);\n      }\n    };\n  };\n\n  SQLitePlugin = function(openargs, openSuccess, openError) {\n    var dbname;\n    if (!(openargs && openargs['name'])) {\n      throw newSQLError(\"Cannot create a SQLitePlugin db instance without a db name\");\n    }\n    dbname = openargs.name;\n    if (typeof dbname !== 'string') {\n      throw newSQLError('sqlite plugin database name must be a string');\n    }\n    this.openargs = openargs;\n    this.dbname = dbname;\n    this.openSuccess = openSuccess;\n    this.openError = openError;\n    this.openSuccess || (this.openSuccess = function() {\n      console.log(\"DB opened: \" + dbname);\n    });\n    this.openError || (this.openError = function(e) {\n      console.log(e.message);\n    });\n    this.open(this.openSuccess, this.openError);\n  };\n\n  SQLitePlugin.prototype.databaseFeatures = {\n    isSQLitePluginDatabase: true\n  };\n\n  SQLitePlugin.prototype.openDBs = {};\n\n  SQLitePlugin.prototype.addTransaction = function(t) {\n    if (!txLocks[this.dbname]) {\n      txLocks[this.dbname] = {\n        queue: [],\n        inProgress: false\n      };\n    }\n    txLocks[this.dbname].queue.push(t);\n    if (this.dbname in this.openDBs && this.openDBs[this.dbname] !== DB_STATE_INIT) {\n      this.startNextTransaction();\n    } else {\n      if (this.dbname in this.openDBs) {\n        console.log('new transaction is waiting for open operation');\n      } else {\n        console.log('database is closed, new transaction is [stuck] waiting until db is opened again!');\n      }\n    }\n  };\n\n  SQLitePlugin.prototype.transaction = function(fn, error, success) {\n    if (!this.openDBs[this.dbname]) {\n      error(newSQLError('database not open'));\n      return;\n    }\n    this.addTransaction(new SQLitePluginTransaction(this, fn, error, success, true, false));\n  };\n\n  SQLitePlugin.prototype.readTransaction = function(fn, error, success) {\n    if (!this.openDBs[this.dbname]) {\n      error(newSQLError('database not open'));\n      return;\n    }\n    this.addTransaction(new SQLitePluginTransaction(this, fn, error, success, false, true));\n  };\n\n  SQLitePlugin.prototype.startNextTransaction = function() {\n    var self;\n    self = this;\n    nextTick((function(_this) {\n      return function() {\n        var txLock;\n        if (!(_this.dbname in _this.openDBs) || _this.openDBs[_this.dbname] !== DB_STATE_OPEN) {\n          console.log('cannot start next transaction: database not open');\n          return;\n        }\n        txLock = txLocks[self.dbname];\n        if (!txLock) {\n          console.log('cannot start next transaction: database connection is lost');\n          return;\n        } else if (txLock.queue.length > 0 && !txLock.inProgress) {\n          txLock.inProgress = true;\n          txLock.queue.shift().start();\n        }\n      };\n    })(this));\n  };\n\n  SQLitePlugin.prototype.abortAllPendingTransactions = function() {\n    var j, len1, ref, tx, txLock;\n    txLock = txLocks[this.dbname];\n    if (!!txLock && txLock.queue.length > 0) {\n      ref = txLock.queue;\n      for (j = 0, len1 = ref.length; j < len1; j++) {\n        tx = ref[j];\n        tx.abortFromQ(newSQLError('Invalid database handle'));\n      }\n      txLock.queue = [];\n      txLock.inProgress = false;\n    }\n  };\n\n  SQLitePlugin.prototype.open = function(success, error) {\n    var openerrorcb, opensuccesscb;\n    if (this.dbname in this.openDBs) {\n      console.log('database already open: ' + this.dbname);\n      nextTick((function(_this) {\n        return function() {\n          success(_this);\n        };\n      })(this));\n    } else {\n      console.log('OPEN database: ' + this.dbname);\n      opensuccesscb = (function(_this) {\n        return function() {\n          var txLock;\n          console.log('OPEN database: ' + _this.dbname + ' - OK');\n          if (!_this.openDBs[_this.dbname]) {\n            console.log('database was closed during open operation');\n          }\n          if (_this.dbname in _this.openDBs) {\n            _this.openDBs[_this.dbname] = DB_STATE_OPEN;\n          }\n          if (!!success) {\n            success(_this);\n          }\n          txLock = txLocks[_this.dbname];\n          if (!!txLock && txLock.queue.length > 0 && !txLock.inProgress) {\n            _this.startNextTransaction();\n          }\n        };\n      })(this);\n      openerrorcb = (function(_this) {\n        return function() {\n          console.log('OPEN database: ' + _this.dbname + ' FAILED, aborting any pending transactions');\n          if (!!error) {\n            error(newSQLError('Could not open database'));\n          }\n          delete _this.openDBs[_this.dbname];\n          _this.abortAllPendingTransactions();\n        };\n      })(this);\n      this.openDBs[this.dbname] = DB_STATE_INIT;\n      cordova.exec(opensuccesscb, openerrorcb, \"SQLitePlugin\", \"open\", [this.openargs]);\n    }\n  };\n\n  SQLitePlugin.prototype.close = function(success, error) {\n    if (this.dbname in this.openDBs) {\n      if (txLocks[this.dbname] && txLocks[this.dbname].inProgress) {\n        console.log('cannot close: transaction is in progress');\n        error(newSQLError('database cannot be closed while a transaction is in progress'));\n        return;\n      }\n      console.log('CLOSE database: ' + this.dbname);\n      delete this.openDBs[this.dbname];\n      if (txLocks[this.dbname]) {\n        console.log('closing db with transaction queue length: ' + txLocks[this.dbname].queue.length);\n      } else {\n        console.log('closing db with no transaction lock state');\n      }\n      cordova.exec(success, error, \"SQLitePlugin\", \"close\", [\n        {\n          path: this.dbname\n        }\n      ]);\n    } else {\n      console.log('cannot close: database is not open');\n      if (error) {\n        nextTick(function() {\n          return error();\n        });\n      }\n    }\n  };\n\n  SQLitePlugin.prototype.executeSql = function(statement, params, success, error) {\n    var myerror, myfn, mysuccess;\n    mysuccess = function(t, r) {\n      if (!!success) {\n        return success(r);\n      }\n    };\n    myerror = function(t, e) {\n      if (!!error) {\n        return error(e);\n      }\n    };\n    myfn = function(tx) {\n      tx.addStatement(statement, params, mysuccess, myerror);\n    };\n    this.addTransaction(new SQLitePluginTransaction(this, myfn, null, null, false, false));\n  };\n\n  SQLitePlugin.prototype.sqlBatch = function(sqlStatements, success, error) {\n    var batchList, j, len1, myfn, st;\n    if (!sqlStatements || sqlStatements.constructor !== Array) {\n      throw newSQLError('sqlBatch expects an array');\n    }\n    batchList = [];\n    for (j = 0, len1 = sqlStatements.length; j < len1; j++) {\n      st = sqlStatements[j];\n      if (st.constructor === Array) {\n        if (st.length === 0) {\n          throw newSQLError('sqlBatch array element of zero (0) length');\n        }\n        batchList.push({\n          sql: st[0],\n          params: st.length === 0 ? [] : st[1]\n        });\n      } else {\n        batchList.push({\n          sql: st,\n          params: []\n        });\n      }\n    }\n    myfn = function(tx) {\n      var elem, k, len2, results;\n      results = [];\n      for (k = 0, len2 = batchList.length; k < len2; k++) {\n        elem = batchList[k];\n        results.push(tx.addStatement(elem.sql, elem.params, null, null));\n      }\n      return results;\n    };\n    this.addTransaction(new SQLitePluginTransaction(this, myfn, error, success, true, false));\n  };\n\n  SQLitePluginTransaction = function(db, fn, error, success, txlock, readOnly) {\n    if (typeof fn !== \"function\") {\n\n      /*\n      This is consistent with the implementation in Chrome -- it\n      throws if you pass anything other than a function. This also\n      prevents us from stalling our txQueue if somebody passes a\n      false value for fn.\n       */\n      throw newSQLError(\"transaction expected a function\");\n    }\n    this.db = db;\n    this.fn = fn;\n    this.error = error;\n    this.success = success;\n    this.txlock = txlock;\n    this.readOnly = readOnly;\n    this.executes = [];\n    if (txlock) {\n      this.addStatement(\"BEGIN\", [], null, function(tx, err) {\n        throw newSQLError(\"unable to begin transaction: \" + err.message, err.code);\n      });\n    } else {\n      this.addStatement(\"SELECT 1\", [], null, null);\n    }\n  };\n\n  SQLitePluginTransaction.prototype.start = function() {\n    var err;\n    try {\n      this.fn(this);\n      this.run();\n    } catch (error1) {\n      err = error1;\n      txLocks[this.db.dbname].inProgress = false;\n      this.db.startNextTransaction();\n      if (this.error) {\n        this.error(newSQLError(err));\n      }\n    }\n  };\n\n  SQLitePluginTransaction.prototype.executeSql = function(sql, values, success, error) {\n    if (this.finalized) {\n      throw {\n        message: 'InvalidStateError: DOM Exception 11: This transaction is already finalized. Transactions are committed after its success or failure handlers are called. If you are using a Promise to handle callbacks, be aware that implementations following the A+ standard adhere to run-to-completion semantics and so Promise resolution occurs on a subsequent tick and therefore after the transaction commits.',\n        code: 11\n      };\n      return;\n    }\n    if (this.readOnly && READ_ONLY_REGEX.test(sql)) {\n      this.handleStatementFailure(error, {\n        message: 'invalid sql for a read-only transaction'\n      });\n      return;\n    }\n    this.addStatement(sql, values, success, error);\n  };\n\n  SQLitePluginTransaction.prototype.addStatement = function(sql, values, success, error) {\n    var j, len1, params, sqlStatement, t, v;\n    sqlStatement = typeof sql === 'string' ? sql : sql.toString();\n    params = [];\n    if (!!values && values.constructor === Array) {\n      for (j = 0, len1 = values.length; j < len1; j++) {\n        v = values[j];\n        t = typeof v;\n        params.push((v === null || v === void 0 ? null : t === 'number' || t === 'string' ? v : v.toString()));\n      }\n    }\n    this.executes.push({\n      success: success,\n      error: error,\n      sql: sqlStatement,\n      params: params\n    });\n  };\n\n  SQLitePluginTransaction.prototype.handleStatementSuccess = function(handler, response) {\n    var payload, rows;\n    if (!handler) {\n      return;\n    }\n    rows = response.rows || [];\n    payload = {\n      rows: {\n        item: function(i) {\n          return rows[i];\n        },\n        length: rows.length\n      },\n      rowsAffected: response.rowsAffected || 0,\n      insertId: response.insertId || void 0\n    };\n    handler(this, payload);\n  };\n\n  SQLitePluginTransaction.prototype.handleStatementFailure = function(handler, response) {\n    if (!handler) {\n      throw newSQLError(\"a statement with no error handler failed: \" + response.message, response.code);\n    }\n    if (handler(this, response) !== false) {\n      throw newSQLError(\"a statement error callback did not return false: \" + response.message, response.code);\n    }\n  };\n\n  SQLitePluginTransaction.prototype.run = function() {\n    var batchExecutes, handlerFor, i, mycb, mycbmap, request, tropts, tx, txFailure, waiting;\n    txFailure = null;\n    tropts = [];\n    batchExecutes = this.executes;\n    waiting = batchExecutes.length;\n    this.executes = [];\n    tx = this;\n    handlerFor = function(index, didSucceed) {\n      return function(response) {\n        var err;\n        if (!txFailure) {\n          try {\n            if (didSucceed) {\n              tx.handleStatementSuccess(batchExecutes[index].success, response);\n            } else {\n              tx.handleStatementFailure(batchExecutes[index].error, newSQLError(response));\n            }\n          } catch (error1) {\n            err = error1;\n            txFailure = newSQLError(err);\n          }\n        }\n        if (--waiting === 0) {\n          if (txFailure) {\n            tx.executes = [];\n            tx.abort(txFailure);\n          } else if (tx.executes.length > 0) {\n            tx.run();\n          } else {\n            tx.finish();\n          }\n        }\n      };\n    };\n    mycbmap = {};\n    i = 0;\n    while (i < batchExecutes.length) {\n      request = batchExecutes[i];\n      mycbmap[i] = {\n        success: handlerFor(i, true),\n        error: handlerFor(i, false)\n      };\n      tropts.push({\n        qid: null,\n        sql: request.sql,\n        params: request.params\n      });\n      i++;\n    }\n    mycb = function(result) {\n      var j, q, r, ref, res, resultIndex, type;\n      for (resultIndex = j = 0, ref = result.length - 1; 0 <= ref ? j <= ref : j >= ref; resultIndex = 0 <= ref ? ++j : --j) {\n        r = result[resultIndex];\n        type = r.type;\n        res = r.result;\n        q = mycbmap[resultIndex];\n        if (q) {\n          if (q[type]) {\n            q[type](res);\n          }\n        }\n      }\n    };\n    cordova.exec(mycb, null, \"SQLitePlugin\", \"backgroundExecuteSqlBatch\", [\n      {\n        dbargs: {\n          dbname: this.db.dbname\n        },\n        executes: tropts\n      }\n    ]);\n  };\n\n  SQLitePluginTransaction.prototype.abort = function(txFailure) {\n    var failed, succeeded, tx;\n    if (this.finalized) {\n      return;\n    }\n    tx = this;\n    succeeded = function(tx) {\n      txLocks[tx.db.dbname].inProgress = false;\n      tx.db.startNextTransaction();\n      if (tx.error && typeof tx.error === 'function') {\n        tx.error(txFailure);\n      }\n    };\n    failed = function(tx, err) {\n      txLocks[tx.db.dbname].inProgress = false;\n      tx.db.startNextTransaction();\n      if (tx.error && typeof tx.error === 'function') {\n        tx.error(newSQLError('error while trying to roll back: ' + err.message, err.code));\n      }\n    };\n    this.finalized = true;\n    if (this.txlock) {\n      this.addStatement(\"ROLLBACK\", [], succeeded, failed);\n      this.run();\n    } else {\n      succeeded(tx);\n    }\n  };\n\n  SQLitePluginTransaction.prototype.finish = function() {\n    var failed, succeeded, tx;\n    if (this.finalized) {\n      return;\n    }\n    tx = this;\n    succeeded = function(tx) {\n      txLocks[tx.db.dbname].inProgress = false;\n      tx.db.startNextTransaction();\n      if (tx.success && typeof tx.success === 'function') {\n        tx.success();\n      }\n    };\n    failed = function(tx, err) {\n      txLocks[tx.db.dbname].inProgress = false;\n      tx.db.startNextTransaction();\n      if (tx.error && typeof tx.error === 'function') {\n        tx.error(newSQLError('error while trying to commit: ' + err.message, err.code));\n      }\n    };\n    this.finalized = true;\n    if (this.txlock) {\n      this.addStatement(\"COMMIT\", [], succeeded, failed);\n      this.run();\n    } else {\n      succeeded(tx);\n    }\n  };\n\n  SQLitePluginTransaction.prototype.abortFromQ = function(sqlerror) {\n    if (this.error) {\n      this.error(sqlerror);\n    }\n  };\n\n  dblocations = [\"docs\", \"libs\", \"nosync\"];\n\n  iosLocationMap = {\n    'default': 'nosync',\n    'Documents': 'docs',\n    'Library': 'libs'\n  };\n\n  SQLiteFactory = {\n\n    /*\n    NOTE: this function should NOT be translated from Javascript\n    back to CoffeeScript by js2coffee.\n    If this function is edited in Javascript then someone will\n    have to translate it back to CoffeeScript by hand.\n     */\n    openDatabase: argsArray(function(args) {\n      var dblocation, errorcb, okcb, openargs;\n      if (args.length < 1 || !args[0]) {\n        throw newSQLError('Sorry missing mandatory open arguments object in openDatabase call');\n      }\n      if (args[0].constructor === String) {\n        throw newSQLError('Sorry first openDatabase argument must be an object');\n      }\n      openargs = args[0];\n      if (!openargs.name) {\n        throw newSQLError('Database name value is missing in openDatabase call');\n      }\n      if (!openargs.iosDatabaseLocation && !openargs.location && openargs.location !== 0) {\n        throw newSQLError('Database location or iosDatabaseLocation setting is now mandatory in openDatabase call.');\n      }\n      if (!!openargs.location && !!openargs.iosDatabaseLocation) {\n        throw newSQLError('AMBIGUOUS: both location and iosDatabaseLocation settings are present in openDatabase call. Please use either setting, not both.');\n      }\n      dblocation = !!openargs.location && openargs.location === 'default' ? iosLocationMap['default'] : !!openargs.iosDatabaseLocation ? iosLocationMap[openargs.iosDatabaseLocation] : dblocations[openargs.location];\n      if (!dblocation) {\n        throw newSQLError('Valid iOS database location could not be determined in openDatabase call');\n      }\n      openargs.dblocation = dblocation;\n      if (!!openargs.createFromLocation && openargs.createFromLocation === 1) {\n        openargs.createFromResource = \"1\";\n      }\n      if (!!openargs.androidDatabaseImplementation && openargs.androidDatabaseImplementation === 2) {\n        openargs.androidOldDatabaseImplementation = 1;\n      }\n      if (!!openargs.androidLockWorkaround && openargs.androidLockWorkaround === 1) {\n        openargs.androidBugWorkaround = 1;\n      }\n      okcb = null;\n      errorcb = null;\n      if (args.length >= 2) {\n        okcb = args[1];\n        if (args.length > 2) {\n          errorcb = args[2];\n        }\n      }\n      return new SQLitePlugin(openargs, okcb, errorcb);\n    }),\n    deleteDatabase: function(first, success, error) {\n      var args, dblocation, dbname;\n      args = {};\n      if (first.constructor === String) {\n        throw newSQLError('Sorry first deleteDatabase argument must be an object');\n      } else {\n        if (!(first && first['name'])) {\n          throw new Error(\"Please specify db name\");\n        }\n        dbname = first.name;\n        if (typeof dbname !== 'string') {\n          throw newSQLError('delete database name must be a string');\n        }\n        args.path = dbname;\n      }\n      if (!first.iosDatabaseLocation && !first.location && first.location !== 0) {\n        throw newSQLError('Database location or iosDatabaseLocation setting is now mandatory in deleteDatabase call.');\n      }\n      if (!!first.location && !!first.iosDatabaseLocation) {\n        throw newSQLError('AMBIGUOUS: both location and iosDatabaseLocation settings are present in deleteDatabase call. Please use either setting value, not both.');\n      }\n      dblocation = !!first.location && first.location === 'default' ? iosLocationMap['default'] : !!first.iosDatabaseLocation ? iosLocationMap[first.iosDatabaseLocation] : dblocations[first.location];\n      if (!dblocation) {\n        throw newSQLError('Valid iOS database location could not be determined in deleteDatabase call');\n      }\n      args.dblocation = dblocation;\n      delete SQLitePlugin.prototype.openDBs[args.path];\n      return cordova.exec(success, error, \"SQLitePlugin\", \"delete\", [args]);\n    }\n  };\n\n  SelfTest = {\n    DBNAME: '___$$$___litehelpers___$$$___test___$$$___.db',\n    start: function(successcb, errorcb) {\n      SQLiteFactory.deleteDatabase({\n        name: SelfTest.DBNAME,\n        location: 'default'\n      }, (function() {\n        return SelfTest.start2(successcb, errorcb);\n      }), (function() {\n        return SelfTest.start2(successcb, errorcb);\n      }));\n    },\n    start2: function(successcb, errorcb) {\n      SQLiteFactory.openDatabase({\n        name: SelfTest.DBNAME,\n        location: 'default'\n      }, function(db) {\n        var check1;\n        check1 = false;\n        return db.transaction(function(tx) {\n          return tx.executeSql('SELECT UPPER(\"Test\") AS upperText', [], function(ignored, resutSet) {\n            if (!resutSet.rows) {\n              return SelfTest.finishWithError(errorcb, 'Missing resutSet.rows');\n            }\n            if (!resutSet.rows.length) {\n              return SelfTest.finishWithError(errorcb, 'Missing resutSet.rows.length');\n            }\n            if (resutSet.rows.length !== 1) {\n              return SelfTest.finishWithError(errorcb, \"Incorrect resutSet.rows.length value: \" + resutSet.rows.length + \" (expected: 1)\");\n            }\n            if (!resutSet.rows.item(0).upperText) {\n              return SelfTest.finishWithError(errorcb, 'Missing resutSet.rows.item(0).upperText');\n            }\n            if (resutSet.rows.item(0).upperText !== 'TEST') {\n              return SelfTest.finishWithError(errorcb, \"Incorrect resutSet.rows.item(0).upperText value: \" + (resutSet.rows.item(0).data) + \" (expected: 'TEST')\");\n            }\n            check1 = true;\n          }, function(sql_err) {\n            SelfTest.finishWithError(errorcb, \"SQL error: \" + sql_err);\n          });\n        }, function(tx_err) {\n          SelfTest.finishWithError(errorcb, \"TRANSACTION error: \" + tx_err);\n        }, function() {\n          if (!check1) {\n            return SelfTest.finishWithError(errorcb, 'Did not get expected upperText result data');\n          }\n          delete db.openDBs[SelfTest.DBNAME];\n          delete txLocks[SelfTest.DBNAME];\n          SelfTest.start3(successcb, errorcb);\n        });\n      }, function(open_err) {\n        return SelfTest.finishWithError(errorcb, \"Open database error: \" + open_err);\n      });\n    },\n    start3: function(successcb, errorcb) {\n      SQLiteFactory.openDatabase({\n        name: SelfTest.DBNAME,\n        location: 'default'\n      }, function(db) {\n        return db.sqlBatch(['CREATE TABLE TestTable(id integer primary key autoincrement unique, data);', ['INSERT INTO TestTable (data) VALUES (?);', ['test-value']]], function() {\n          var firstid;\n          firstid = -1;\n          return db.executeSql('SELECT id, data FROM TestTable', [], function(resutSet) {\n            if (!resutSet.rows) {\n              SelfTest.finishWithError(errorcb, 'Missing resutSet.rows');\n              return;\n            }\n            if (!resutSet.rows.length) {\n              SelfTest.finishWithError(errorcb, 'Missing resutSet.rows.length');\n              return;\n            }\n            if (resutSet.rows.length !== 1) {\n              SelfTest.finishWithError(errorcb, \"Incorrect resutSet.rows.length value: \" + resutSet.rows.length + \" (expected: 1)\");\n              return;\n            }\n            if (resutSet.rows.item(0).id === void 0) {\n              SelfTest.finishWithError(errorcb, 'Missing resutSet.rows.item(0).id');\n              return;\n            }\n            firstid = resutSet.rows.item(0).id;\n            if (!resutSet.rows.item(0).data) {\n              SelfTest.finishWithError(errorcb, 'Missing resutSet.rows.item(0).data');\n              return;\n            }\n            if (resutSet.rows.item(0).data !== 'test-value') {\n              SelfTest.finishWithError(errorcb, \"Incorrect resutSet.rows.item(0).data value: \" + (resutSet.rows.item(0).data) + \" (expected: 'test-value')\");\n              return;\n            }\n            return db.transaction(function(tx) {\n              return tx.executeSql('UPDATE TestTable SET data = ?', ['new-value']);\n            }, function(tx_err) {\n              return SelfTest.finishWithError(errorcb, \"UPDATE transaction error: \" + tx_err);\n            }, function() {\n              var readTransactionFinished;\n              readTransactionFinished = false;\n              return db.readTransaction(function(tx2) {\n                return tx2.executeSql('SELECT id, data FROM TestTable', [], function(ignored, resutSet2) {\n                  if (!resutSet2.rows) {\n                    throw newSQLError('Missing resutSet2.rows');\n                  }\n                  if (!resutSet2.rows.length) {\n                    throw newSQLError('Missing resutSet2.rows.length');\n                  }\n                  if (resutSet2.rows.length !== 1) {\n                    throw newSQLError(\"Incorrect resutSet2.rows.length value: \" + resutSet2.rows.length + \" (expected: 1)\");\n                  }\n                  if (!resutSet2.rows.item(0).id) {\n                    throw newSQLError('Missing resutSet2.rows.item(0).id');\n                  }\n                  if (resutSet2.rows.item(0).id !== firstid) {\n                    throw newSQLError(\"resutSet2.rows.item(0).id value \" + (resutSet2.rows.item(0).id) + \" does not match previous primary key id value (\" + firstid + \")\");\n                  }\n                  if (!resutSet2.rows.item(0).data) {\n                    throw newSQLError('Missing resutSet2.rows.item(0).data');\n                  }\n                  if (resutSet2.rows.item(0).data !== 'new-value') {\n                    throw newSQLError(\"Incorrect resutSet2.rows.item(0).data value: \" + (resutSet2.rows.item(0).data) + \" (expected: 'test-value')\");\n                  }\n                  return readTransactionFinished = true;\n                });\n              }, function(tx2_err) {\n                return SelfTest.finishWithError(errorcb, \"readTransaction error: \" + tx2_err);\n              }, function() {\n                if (!readTransactionFinished) {\n                  SelfTest.finishWithError(errorcb, 'readTransaction did not finish');\n                  return;\n                }\n                return db.transaction(function(tx3) {\n                  tx3.executeSql('DELETE FROM TestTable');\n                  return tx3.executeSql('INSERT INTO TestTable (data) VALUES(?)', [123]);\n                }, function(tx3_err) {\n                  return SelfTest.finishWithError(errorcb, \"DELETE transaction error: \" + tx3_err);\n                }, function() {\n                  var secondReadTransactionFinished;\n                  secondReadTransactionFinished = false;\n                  return db.readTransaction(function(tx4) {\n                    return tx4.executeSql('SELECT id, data FROM TestTable', [], function(ignored, resutSet3) {\n                      if (!resutSet3.rows) {\n                        throw newSQLError('Missing resutSet3.rows');\n                      }\n                      if (!resutSet3.rows.length) {\n                        throw newSQLError('Missing resutSet3.rows.length');\n                      }\n                      if (resutSet3.rows.length !== 1) {\n                        throw newSQLError(\"Incorrect resutSet3.rows.length value: \" + resutSet3.rows.length + \" (expected: 1)\");\n                      }\n                      if (!resutSet3.rows.item(0).id) {\n                        throw newSQLError('Missing resutSet3.rows.item(0).id');\n                      }\n                      if (resutSet3.rows.item(0).id === firstid) {\n                        throw newSQLError(\"resutSet3.rows.item(0).id value \" + (resutSet3.rows.item(0).id) + \" incorrectly matches previous unique key id value value (\" + firstid + \")\");\n                      }\n                      if (!resutSet3.rows.item(0).data) {\n                        throw newSQLError('Missing resutSet3.rows.item(0).data');\n                      }\n                      if (resutSet3.rows.item(0).data !== 123) {\n                        throw newSQLError(\"Incorrect resutSet3.rows.item(0).data value: \" + (resutSet3.rows.item(0).data) + \" (expected 123)\");\n                      }\n                      return secondReadTransactionFinished = true;\n                    });\n                  }, function(tx4_err) {\n                    return SelfTest.finishWithError(errorcb, \"second readTransaction error: \" + tx4_err);\n                  }, function() {\n                    if (!secondReadTransactionFinished) {\n                      SelfTest.finishWithError(errorcb, 'second readTransaction did not finish');\n                      return;\n                    }\n                    return db.close(function() {\n                      return SQLiteFactory.deleteDatabase({\n                        name: SelfTest.DBNAME,\n                        location: 'default'\n                      }, successcb, function(cleanup_err) {\n                        return SelfTest.finishWithError(errorcb, \"Cleanup error: \" + cleanup_err);\n                      });\n                    }, function(close_err) {\n                      return SelfTest.finishWithError(errorcb, \"close error: \" + close_err);\n                    });\n                  });\n                });\n              });\n            });\n          }, function(select_err) {\n            return SelfTest.finishWithError(errorcb, \"SELECT error: \" + select_err);\n          });\n        }, function(batch_err) {\n          return SelfTest.finishWithError(errorcb, \"sql batch error: \" + batch_err);\n        });\n      }, function(open_err) {\n        return SelfTest.finishWithError(errorcb, \"Open database error: \" + open_err);\n      });\n    },\n    finishWithError: function(errorcb, message) {\n      SQLiteFactory.deleteDatabase({\n        name: SelfTest.DBNAME,\n        location: 'default'\n      }, function() {\n        return errorcb(newSQLError(message));\n      }, function(err2) {\n        return errorcb(newSQLError(\"Cleanup error: \" + err2 + \" for error: \" + message));\n      });\n    }\n  };\n\n  root.sqlitePlugin = {\n    sqliteFeatures: {\n      isSQLitePlugin: true\n    },\n    echoTest: function(okcb, errorcb) {\n      var error, ok;\n      ok = function(s) {\n        if (s === 'test-string') {\n          return okcb();\n        } else {\n          return errorcb(\"Mismatch: got: '\" + s + \"' expected 'test-string'\");\n        }\n      };\n      error = function(e) {\n        return errorcb(e);\n      };\n      return cordova.exec(ok, error, \"SQLitePlugin\", \"echoStringValue\", [\n        {\n          value: 'test-string'\n        }\n      ]);\n    },\n    selfTest: SelfTest.start,\n    openDatabase: SQLiteFactory.openDatabase,\n    deleteDatabase: SQLiteFactory.deleteDatabase\n  };\n\n}).call(this);\n"}